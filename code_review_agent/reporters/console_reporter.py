"""
Console reporter for command-line output.
"""
from typing import List, Dict, Any, Optional
from .base_reporter import BaseReporter
from ..analyzers.base_analyzer import CodeIssue


class ConsoleReporter(BaseReporter):
    """Console reporter for CLI output."""
    
    def __init__(self):
        super().__init__('console')
    
    def generate_report(self, issues: List[CodeIssue], 
                       metadata: Optional[Dict[str, Any]] = None) -> str:
        """Generate a console-friendly report."""
        if not issues:
            return "✅ No issues found - excellent code quality!"
        
        # Get statistics
        stats = self.get_issue_statistics(issues)
        summary = self.generate_summary(issues, metadata)
        
        # Build report
        report_lines = []
        
        # Header
        report_lines.append("📋 Code Review Report")
        report_lines.append("=" * 50)
        report_lines.append(f"Timestamp: {summary['timestamp']}")
        report_lines.append(f"Compliance Score: {summary['compliance_score']}/100")
        report_lines.append(f"Status: {summary['status_message']}")
        report_lines.append("")
        
        # Statistics
        report_lines.append("📊 Issue Summary:")
        report_lines.append(f"   Total Issues: {stats['total']}")
        report_lines.append(f"   🔴 Errors: {stats['by_severity']['error']}")
        report_lines.append(f"   🟡 Warnings: {stats['by_severity']['warning']}")
        report_lines.append(f"   🔵 Info: {stats['by_severity']['info']}")
        report_lines.append(f"   🔧 Auto-fixable: {stats['auto_fixable']}")
        report_lines.append("")
        
        # Group issues by severity
        severity_groups = self.group_issues_by_severity(issues)
        
        # Show errors first
        if severity_groups['error']:
            report_lines.append("🔴 Critical Errors:")
            report_lines.append("-" * 30)
            for issue in severity_groups['error']:
                report_lines.append(self._format_issue(issue))
            report_lines.append("")
        
        # Show warnings
        if severity_groups['warning']:
            report_lines.append("🟡 Warnings:")
            report_lines.append("-" * 30)
            for issue in severity_groups['warning'][:10]:  # Limit to 10
                report_lines.append(self._format_issue(issue))
            
            if len(severity_groups['warning']) > 10:
                report_lines.append(f"   ... and {len(severity_groups['warning']) - 10} more warnings")
            report_lines.append("")
        
        # Show info
        if severity_groups['info']:
            report_lines.append("🔵 Information:")
            report_lines.append("-" * 30)
            for issue in severity_groups['info'][:5]:  # Limit to 5
                report_lines.append(self._format_issue(issue))
            
            if len(severity_groups['info']) > 5:
                report_lines.append(f"   ... and {len(severity_groups['info']) - 5} more info items")
            report_lines.append("")
        
        # Most common issues
        if stats['most_common_rules']:
            report_lines.append("🔥 Most Common Issues:")
            report_lines.append("-" * 30)
            for rule in stats['most_common_rules'][:5]:
                auto_fix_icon = "🔧" if rule['auto_fixable'] else "👁️"
                report_lines.append(f"   {auto_fix_icon} {rule['rule_id']} ({rule['count']} occurrences)")
            report_lines.append("")
        
        # Recommendations
        if summary['recommendations']:
            report_lines.append("💡 Recommendations:")
            report_lines.append("-" * 30)
            for rec in summary['recommendations']:
                report_lines.append(f"   {rec}")
            report_lines.append("")
        
        # Footer
        report_lines.append("=" * 50)
        report_lines.append("Generated by TypeScript Playwright Cucumber Code Review Agent")
        
        return "\n".join(report_lines)
    
    def _format_issue(self, issue: CodeIssue) -> str:
        """Format a single issue for console output."""
        severity_icon = self.get_severity_icon(issue.severity)
        auto_fix_icon = "🔧" if issue.auto_fixable else ""
        
        line_info = f"Line {issue.line_number}"
        if issue.column > 0:
            line_info += f":{issue.column}"
        
        main_line = f"   {severity_icon} {auto_fix_icon} {line_info}: {issue.description}"
        
        lines = [main_line]
        
        # Add rule ID and category
        if issue.rule_id:
            lines.append(f"      Rule: {issue.rule_id} ({issue.category})")
        
        # Add suggestion if available
        if issue.suggested_fix:
            lines.append(f"      💡 {issue.suggested_fix}")
        
        return "\n".join(lines)
    
    def generate_summary_only(self, issues: List[CodeIssue]) -> str:
        """Generate a brief summary for quick feedback."""
        if not issues:
            return "✅ No issues found!"
        
        stats = self.get_issue_statistics(issues)
        
        summary_parts = []
        
        if stats['by_severity']['error'] > 0:
            summary_parts.append(f"🔴 {stats['by_severity']['error']} errors")
        
        if stats['by_severity']['warning'] > 0:
            summary_parts.append(f"🟡 {stats['by_severity']['warning']} warnings")
        
        if stats['auto_fixable'] > 0:
            summary_parts.append(f"🔧 {stats['auto_fixable']} auto-fixable")
        
        return f"Found {stats['total']} issues: " + ", ".join(summary_parts)
    
    def generate_fix_report(self, fix_result: Dict[str, Any]) -> str:
        """Generate a report for fix results."""
        lines = []
        
        if not fix_result.get('content_changed', False):
            return "ℹ️  No fixes were applied - code is already in good shape!"
        
        lines.append("🔧 Fix Results")
        lines.append("=" * 30)
        
        applied_fixes = fix_result.get('applied_fixes', [])
        manual_suggestions = fix_result.get('manual_suggestions', [])
        
        if applied_fixes:
            lines.append(f"✅ Applied {len(applied_fixes)} automated fixes:")
            for fix in applied_fixes:
                lines.append(f"   • {fix.get('description', 'Unknown fix')}")
                if 'line_number' in fix:
                    lines.append(f"     Line {fix['line_number']}")
            lines.append("")
        
        if manual_suggestions:
            lines.append(f"💡 {len(manual_suggestions)} issues require manual attention:")
            for suggestion in manual_suggestions[:5]:  # Limit to 5
                lines.append(f"   • {suggestion.get('title', 'Manual fix needed')}")
                if suggestion.get('estimated_effort'):
                    lines.append(f"     Effort: {suggestion['estimated_effort']}")
            
            if len(manual_suggestions) > 5:
                lines.append(f"   ... and {len(manual_suggestions) - 5} more suggestions")
            lines.append("")
        
        # Next steps
        next_steps = fix_result.get('next_steps', [])
        if next_steps:
            lines.append("📋 Next Steps:")
            for step in next_steps:
                lines.append(f"   {step}")
            lines.append("")
        
        # Quality improvement
        quality_improvement = fix_result.get('quality_improvement', {})
        if quality_improvement:
            improvement_score = quality_improvement.get('improvement_score', 0)
            lines.append(f"📈 Quality Improvement: {improvement_score:.1f}%")
        
        return "\n".join(lines)
